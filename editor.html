<!--
TODO:
- Auto population of certain constant objects like ground and walls
- Improve grid rendering performance by only drawing visible lines and using a single path for all lines instead of individual strokes
- Add object properties panel for editing attributes like slope, interaction type, etc.
- Add sizing chart for creating different specified room sizes
- Fix rect and line tools
-->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Order is Mercy â€“ Level Editor</title>
    <link rel="icon" type="image/x-icon" href="public/assets/favicon.ico" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="editor.css" />
    <script
      src="https://kit.fontawesome.com/0291ccae2e.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <main id="editor">
      <aside class="sidebar">
        <h1>
          <button id="backButton">
            <i class="fa-solid fa-arrow-left"></i>
          </button>
          Level Editor
        </h1>

        <section>
          <h3><i class="fa-regular fa-file-lines"></i> Meta</h3>
          <input id="levelId" placeholder="Level ID" />
          <input id="levelName" placeholder="Level Name" />
          <textarea id="levelNotes" placeholder="Notes"></textarea>
          <select id="levelSize">
            <option value="" selected>Level Size:</option>
            <option value="small">Small (600x400)</option>
            <option value="medium">Medium (1200x800)</option>
            <option value="large" selected>Large (1800x1400)</option>
            <option value="xl">XL (2400x1600)</option>
          </select>
        </section>

        <section>
          <h3><i class="fa-solid fa-cube"></i> Objects</h3>
          <div id="objectPalette"></div>
        </section>

        <section>
          <header>
            <h3><i class="fa-solid fa-hammer"></i> Tools</h3>
            <div id="status">Ready</div>
          </header>

          <div class="tools">
            <button data-tool="paint" class="tool-btn">
              <i class="fa-solid fa-paintbrush"></i> Paint
            </button>
            <button data-tool="rect" class="tool-btn">
              <i class="fa-regular fa-square"></i> Rect
            </button>
            <button data-tool="line" class="tool-btn">
              <i class="fa-solid fa-minus"></i> Line
            </button>
            <button data-tool="erase" class="tool-btn">
              <i class="fa-solid fa-eraser"></i> Erase
            </button>
          </div>
        </section>

        <hr />

        <section class="actions">
          <button id="undoBtn">
            <i class="fa-solid fa-rotate-left"></i>Undo
          </button>
          <button id="redoBtn">
            <i class="fa-solid fa-rotate-right"></i>Redo
          </button>
          <button id="clearBtn">
            <i class="fa-solid fa-trash-can"></i>Clear
          </button>
          <button id="saveBtn">
            <i class="fa-solid fa-file-export"></i>Export JSON
          </button>
        </section>
      </aside>
      <div id="performance">FPS:</div>
      <div id="position">
        <header>Editor Position</header>
        x: 0, y: 0
        <header>Camera</header>
        x: 0, y: 0
        <header>Mouse World Pos</header>
        x: 0, y: 0
        <header>Game Position</header>
        x: 0, y: 0
      </div>
      <canvas id="editorCanvas"> </canvas>
    </main>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const backButton = document.getElementById("backButton");
        backButton.addEventListener("click", () => {
          window.location.href = "index.html";
        });

        let lastFrame = performance.now();

        requestAnimationFrame(function loop() {
          const perf = document.getElementById("performance");
          perf.textContent = `FPS: ${Math.round(1000 / (performance.now() - lastFrame))}`;
          lastFrame = performance.now();
          requestAnimationFrame(loop);
        });

        // ==============================
        // CONFIG
        // ==============================

        const TILE = 25;
        const MAX_WIDTH = 1800;
        const MAX_HEIGHT = 1400;

        const roomSizes = {
          small: { width: 600, height: 400 },
          medium: { width: 1200, height: 800 },
          large: { width: 1800, height: 1400 },
          xl: { width: 2400, height: 1600 },
        };

        let camera = {
          x: 0,
          y: 0,
          zoom: 1,
        };

        // ==============================
        // OBJECT DEFINITIONS
        // ==============================

        const OBJECT_DEFS = {
          ground: { color: "#1d1103", type: "ground", text: "Ground" },
          platform: { color: "#56381a", type: "platform", text: "Platform" },
          wall: { color: "#111111", type: "wall", text: "Wall" },
          ramp_up: {
            color: "#444444",
            type: "ramp",
            slope: 1,
            text: "Ramp Up",
          },
          ramp_down: {
            color: "#666666",
            type: "ramp",
            slope: -1,
            text: "Ramp Down",
          },
          door: {
            color: "#57391a",
            type: "interactable",
            interaction: "door",
            direction: "left",
            height: 3,
            text: "Door",
          },
          player: {
            color: "#1e90ff",
            type: "playerSpawn",
            height: 2,
            text: "Player",
          },
          enemy: {
            color: "#8b0000",
            type: "enemy",
            height: 2,
            text: "Enemy",
          },
        };

        // ==============================
        // STATE
        // ==============================

        let currentTool = "paint";
        let currentObject = "ground";

        let objects = [];
        let undoStack = [];
        let redoStack = [];

        let dragStart = null;

        let isPanning = false;
        let panStart = null;

        // ==============================
        // CANVAS SETUP
        // ==============================

        const canvas = document.getElementById("editorCanvas");
        const ctx = canvas.getContext("2d");

        canvas.width = MAX_WIDTH;
        canvas.height = MAX_HEIGHT;

        // ==============================
        // UI INIT
        // ==============================

        const palette = document.getElementById("objectPalette");
        Object.entries(OBJECT_DEFS).forEach(([name, spec]) => {
          const btn = document.createElement("button");

          btn.className = "object-btn";
          btn.textContent = spec.text;
          btn.style.background = spec.color;
          palette.appendChild(btn);

          // Single click handler: set current object and toggle selected class
          btn.addEventListener("click", () => {
            currentObject = name;
            document
              .querySelectorAll(".object-btn")
              .forEach((b) => b.classList.remove("selected"));
            btn.classList.add("selected");
            document.getElementById("status").textContent =
              `Tool: ${currentTool}, Object: ${currentObject}`;
          });
        });

        // Mark the first palette button selected by default
        const firstBtn = palette.querySelector(".object-btn");
        if (firstBtn) {
          firstBtn.classList.add("selected");
          currentObject = Object.keys(OBJECT_DEFS)[0];
          document.getElementById("status").textContent =
            `Tool: ${currentTool}, Object: ${currentObject}`;
        }

        document.querySelectorAll("[data-tool]").forEach((btn) => {
          // Add selected tool to status
          btn.onclick = () => {
            currentTool = btn.dataset.tool;
            document
              .querySelectorAll(".tool-btn")
              .forEach((b) => b.classList.remove("selected"));
            btn.classList.add("selected");
            document.getElementById("status").textContent =
              `Tool: ${currentTool}, Object: ${currentObject}`;
          };
        });

        const firstToolBtn = document.querySelector("[data-tool]");
        if (firstToolBtn) {
          firstToolBtn.classList.add("selected");
          currentTool = firstToolBtn.dataset.tool;
          document.getElementById("status").textContent =
            `Tool: ${currentTool}, Object: ${currentObject}`;
        }

        document.getElementById("undoBtn").onclick = undo;
        document.getElementById("redoBtn").onclick = redo;
        document.getElementById("clearBtn").onclick = clearLevel;
        document.getElementById("saveBtn").onclick = exportJSON;

        // ==============================
        // GRID + CAMERA
        // ==============================

        function drawGrid() {
          const startX = Math.floor(camera.x / TILE) * TILE;
          const startY = Math.floor(camera.y / TILE) * TILE;
          const endX = camera.x + canvas.width / camera.zoom;
          const endY = camera.y + canvas.height / camera.zoom;

          ctx.strokeStyle = "#2a2a2a";
          ctx.lineWidth = 1.5;

          for (let x = startX; x < endX; x += TILE) {
            ctx.beginPath();
            ctx.moveTo(x, startY);
            ctx.lineTo(x, endY);
            ctx.stroke();
          }

          for (let y = startY; y < endY; y += TILE) {
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(endX, y);
            ctx.stroke();
          }

          // Draw Ground
          ctx.fillStyle = OBJECT_DEFS.ground.color;
          ctx.fillRect(0, MAX_HEIGHT - TILE * 6, MAX_WIDTH, TILE * 6);
          ctx.strokeStyle = "#d5d5d5";
          ctx.strokeRect(0, MAX_HEIGHT - TILE * 6, MAX_WIDTH, TILE * 6);

          // Draw Walls
          ctx.fillStyle = OBJECT_DEFS.wall.color;
          ctx.fillRect(0, 0, TILE * 2, MAX_HEIGHT - TILE * 9);
          ctx.fillRect(
            MAX_WIDTH - TILE * 2,
            0,
            TILE * 2,
            MAX_HEIGHT - TILE * 9,
          );

          ctx.strokeRect(0, 0, TILE * 2, MAX_HEIGHT - TILE * 9);
          ctx.strokeRect(
            MAX_WIDTH - TILE * 2,
            0,
            TILE * 2,
            MAX_HEIGHT - TILE * 9,
          );

          // Draw Doors
          ctx.fillStyle = OBJECT_DEFS.door.color;
          ctx.fillRect(0, MAX_HEIGHT - TILE * 9, TILE, TILE * 3);
          ctx.fillRect(MAX_WIDTH - TILE, MAX_HEIGHT - TILE * 9, TILE, TILE * 3);
          ctx.strokeRect(0, MAX_HEIGHT - TILE * 9, TILE, TILE * 3);
          ctx.strokeRect(
            MAX_WIDTH - TILE,
            MAX_HEIGHT - TILE * 9,
            TILE,
            TILE * 3,
          );

          // Draw Ceiling
          ctx.fillStyle = OBJECT_DEFS.wall.color;
          ctx.fillRect(TILE * 2, 0, MAX_WIDTH - TILE * 4, TILE);
          ctx.strokeRect(TILE * 2, 0, MAX_WIDTH - TILE * 4, TILE);

          // Push to data
          if (!objects.some((o) => o.type === "ground")) {
            objects.push({
              type: "ground",
              x: 0,
              y: MAX_HEIGHT - TILE * 6,
              width: MAX_WIDTH,
              height: TILE * 6,
            });
          }
          if (!objects.some((o) => o.type === "wall")) {
            objects.push(
              {
                type: "wall",
                x: 0,
                y: 0,
                width: TILE * 2,
                height: MAX_HEIGHT - TILE * 9,
              },
              {
                type: "wall",
                x: MAX_WIDTH - TILE * 2,
                y: 0,
                width: TILE * 2,
                height: MAX_HEIGHT - TILE * 9,
              },
            );
          }

          if (!objects.some((o) => o.type === "door")) {
            objects.push(
              {
                type: "interactable",
                interaction: "door",
                direction: "left",
                x: 0,
                y: MAX_HEIGHT - TILE * 9,
                width: TILE,
                height: TILE * 3,
              },
              {
                type: "interactable",
                interaction: "door",
                direction: "right",
                x: MAX_WIDTH - TILE,
                y: MAX_HEIGHT - TILE * 9,
                width: TILE,
                height: TILE * 3,
              },
            );
          }

          if (!objects.some((o) => o.type === "wall")) {
            objects.push({
              type: "wall",
              x: TILE * 2,
              y: 0,
              width: MAX_WIDTH - TILE * 4,
              height: TILE,
            });
          }
        }

        function drawCameraOverlay() {
          // Camera bounds
          ctx.strokeStyle = "#00ffff";
          ctx.lineWidth = 5;
          ctx.strokeRect(0, 0, MAX_WIDTH, MAX_HEIGHT);

          // Dead zone
          ctx.lineWidth = 2;
          ctx.setLineDash([12, 12]);
          ctx.strokeStyle = "#ff00ff";
          ctx.strokeRect(MAX_WIDTH / 2 - 150, MAX_HEIGHT / 2 - 100, 300, 200);
          ctx.setLineDash([]);
        }

        // ==============================
        // OBJECT DRAWING
        // ==============================

        function drawObjects() {
          for (const obj of objects) {
            const def = Object.values(OBJECT_DEFS).find(
              (d) => d.type === obj.type,
            );
            ctx.fillStyle = def.color;
            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
            ctx.strokeStyle = "#d5d5d5";
            ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
          }
        }

        function redraw() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.setTransform(
            camera.zoom,
            0,
            0,
            camera.zoom,
            -camera.x * camera.zoom,
            -camera.y * camera.zoom,
          );

          drawGrid();
          drawCameraOverlay();
          drawObjects();
        }

        // ==============================
        // INPUT
        // ==============================

        function screenToWorld(x, y) {
          return {
            x: x / camera.zoom + camera.x,
            y: y / camera.zoom + camera.y,
          };
        }

        function getMousePos(e) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY,
          };
        }

        function snap(v) {
          return Math.floor(v / TILE) * TILE;
        }

        document.addEventListener("contextmenu", (event) =>
          event.preventDefault(),
        );

        canvas.addEventListener("mousedown", (e) => {
          switch (e.button) {
            case 0:
              const m = getMousePos(e);
              const world = screenToWorld(m.x, m.y);

              dragStart = {
                x: snap(world.x),
                y: snap(world.y),
              };

              if (currentTool === "paint")
                placeObject(dragStart.x, dragStart.y);
              if (currentTool === "erase") eraseAt(m.x, m.y);
              break;
            case 2:
              isPanning = true;
              panStart = getMousePos(e);
              break;
          }
        });

        canvas.addEventListener("mousemove", (e) => {
          if (!isPanning) return;

          const m = getMousePos(e);
          camera.x -= (m.x - panStart.x) / camera.zoom;
          camera.y -= (m.y - panStart.y) / camera.zoom;
          panStart = m;
          redraw();
        });

        canvas.addEventListener("mousemove", (e) => {
          const m = getMousePos(e);
          const w = screenToWorld(m.x, m.y);
          const gx = Math.floor(w.x / TILE);
          const gy = Math.floor(w.y / TILE);

          document.getElementById("position").innerHTML = `
            <header>Editor Position</header>
            x: ${gx}, y: ${gy}
            <header>Camera</header>
            x: ${Math.round(camera.x)}, y: ${Math.round(camera.y)}
            <header>Mouse World Pos</header>
            x: ${Math.round(w.x)}, y: ${Math.round(w.y)}
            <header>Game Position</header>
            x: ${gx * TILE}, y: ${gy * TILE}
          `;

          let x = snap(w.x);
          let y = snap(w.y);

          // If position has not changed, redraw grid lines
          if (x == snap(w.x) || y == snap(w.y)) {
            redraw();
          }

          ctx.strokeStyle = "#777777";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, MAX_HEIGHT);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(MAX_WIDTH, y);
          ctx.stroke();
        });

        canvas.addEventListener("mouseup", (e) => {
          if (isPanning) {
            isPanning = false;
            return;
          }

          const m = getMousePos(e);
          const world = screenToWorld(m.x, m.y);

          dragStart = {
            x: snap(world.x),
            y: snap(world.y),
          };

          if (currentTool === "rect") placeRect(dragStart, { x: x, y: y });
          if (currentTool === "line") placeLine(dragStart, { x: x, y: y });

          dragStart = null;
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();

          const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
          const mouse = getMousePos(e);
          const world = screenToWorld(mouse.x, mouse.y);

          camera.zoom *= zoomFactor;
          camera.zoom = Math.min(Math.max(camera.zoom, 0.25), 4);

          camera.x = world.x - mouse.x / camera.zoom;
          camera.y = world.y - mouse.y / camera.zoom;

          redraw();
        });

        // ==============================
        // PLACEMENT
        // ==============================

        function pushUndo() {
          undoStack.push(JSON.stringify(objects));
          redoStack.length = 0;
        }

        function placeObject(x, y) {
          const spec = OBJECT_DEFS[currentObject];
          const h = TILE * (spec.height || 1);

          pushUndo();
          objects.push({
            type: spec.type,
            x,
            y: y - h + TILE,
            width: TILE,
            height: h,
            ...(spec.slope !== undefined && { slope: spec.slope }),
            ...(spec.interaction && {
              interaction: spec.interaction,
              direction: spec.direction,
            }),
          });

          redraw();
        }

        function placeRect(a, b) {
          const spec = OBJECT_DEFS[currentObject];
          if (spec.slope) return;

          pushUndo();
          objects.push({
            type: spec.type,
            x: Math.min(a.x, b.x),
            y: Math.min(a.y, b.y),
            width: Math.abs(b.x - a.x) + TILE,
            height: Math.abs(b.y - a.y) + TILE,
          });

          redraw();
        }

        function placeLine(a, b) {
          if (Math.abs(b.x - a.x) >= Math.abs(b.y - a.y))
            placeRect(a, { x: b.x, y: a.y });
          else placeRect(a, { x: a.x, y: b.y });
        }

        function eraseAt(x, y) {
          pushUndo();
          objects = objects.filter(
            (o) =>
              !(
                x >= o.x &&
                x <= o.x + o.width &&
                y >= o.y &&
                y <= o.y + o.height
              ),
          );
          redraw();
        }

        // ==============================
        // UNDO / REDO
        // ==============================

        function undo() {
          if (!undoStack.length) return;
          redoStack.push(JSON.stringify(objects));
          objects = JSON.parse(undoStack.pop());
          redraw();
        }

        function redo() {
          if (!redoStack.length) return;
          undoStack.push(JSON.stringify(objects));
          objects = JSON.parse(redoStack.pop());
          redraw();
        }

        // ==============================
        // EXPORT
        // ==============================

        function exportJSON() {
          const data = {
            id: document.getElementById("levelId").value,
            debug: {
              name: document.getElementById("levelName").value,
              notes: document.getElementById("levelNotes").value,
            },
            size: { width: MAX_WIDTH, height: MAX_HEIGHT },
            camera: {
              bounds: { x: 0, y: 0, width: MAX_WIDTH, height: MAX_HEIGHT },
              deadZone: { width: 300, height: 200 },
            },
            geometry: objects,
          };

          const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: "application/json",
          });

          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = `${data.id || "level"}.json`;
          a.click();
        }

        function clearLevel() {
          pushUndo();
          objects = [];
          redraw();
        }

        redraw();
      });
    </script>
  </body>
</html>
